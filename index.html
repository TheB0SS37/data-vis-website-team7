<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>You've been Hacked!</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
      crossorigin="anonymous"
    />
    <link
      rel="shortcut icon"
      type="image/x-icon"
      href="./assets/computer-hacked-icon-vector.jpg?"
    />
    <link href="styles.css" rel="stylesheet" />
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
      crossorigin="anonymous"
    ></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/ramda/0.20.0/ramda.min.js"></script>
  </head>
  <body data-bs-spy="scroll" data-bs-target="#navbar">
    <nav id="navbar" class="navbar navbar-dark bg-dark sticky-top">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">Team 7</a>
        <div class="bg-dark">
          <ul class="nav">
            <li class="nav-item">
              <a class="nav-link text-white" href="#">Hierarchy</a>
            </li>
            <li class="nav-item">
              <a class="nav-link text-white" href="#tableau-vis-title"
                >Tableau</a
              >
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <!------------ CONTENT ------------>

    <div
      id="hierarchy-vis-title"
      class="container d-flex flex-row justify-content-center"
    >
      <div class="display-3 p-3">Hierarchy Visualization</div>
    </div>
    <div id="container" class="d-flex flex-row justify-content-center"></div>
    <div
      id="tableau-vis-title"
      class="container d-flex flex-row justify-content-center"
    >
      <div class="display-3 p-3">Tableau Visualization</div>
    </div>
    <!-- Tableau Vis Embed -->
    <div class="container d-flex flex-row justify-content-center">
      <div
        class="tableauPlaceholder"
        id="viz1712443739207"
        style="position: relative"
      >
        <noscript
          ><a href="#"
            ><img
              alt="Dashboard 1 "
              src="https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;5X&#47;5X95ZB3RZ&#47;1_rss.png"
              style="border: none" /></a></noscript
        ><object
          class="tableauViz"
          style="display: none; margin-left: auto; margin-right: auto"
        >
          <param name="host_url" value="https%3A%2F%2Fpublic.tableau.com%2F" />
          <param name="embed_code_version" value="3" />
          <param
            name="path"
            value="views&#47;ProjectDashboard3_17123298610860&#47;Dashboard1?:language=en-US&amp;:embed=true&amp;:sid="
          />
          <param name="toolbar" value="yes" />
          <param
            name="static_image"
            value="https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;5X&#47;5X95ZB3RZ&#47;1.png"
          />
          <param name="animate_transition" value="yes" />
          <param name="display_static_image" value="yes" />
          <param name="display_spinner" value="yes" />
          <param name="display_overlay" value="yes" />
          <param name="display_count" value="yes" />
          <param name="language" value="en-US" />
        </object>
      </div>
    </div>
    <script type="text/javascript">
      var divElement = document.getElementById("viz1712443739207");
      var vizElement = divElement.getElementsByTagName("object")[0];

      vizElement.style.maxWidth = "1100px";
      vizElement.style.width = "100%";
      vizElement.style.minHeight = "587px";
      vizElement.style.maxHeight = "1277px";

      var scriptElement = document.createElement("script");
      scriptElement.src =
        "https://public.tableau.com/javascripts/api/viz_v1.js";
      vizElement.parentNode.insertBefore(scriptElement, vizElement);
    </script>
    <!-- End Tableau vis embed -->

    <!------------ JS  ------------>
    <script type="module">
      // D3 Vis /////////////////////////

      // Create node data structure. Children contains other nodes
      const makeNode = (name) => {
        return { name: name, children: [] };
      };

      // Receives an array of row objects and returns the sum of records lost
      const sumTheRecords = (data = []) => {
        return data.reduce((sum, row) => sum + row["records lost"], 0);
      };

      // Creates a unique color based on an index approximation of golden angle
      const selectColor = (number) => {
        const hue = number * 137.508;
        return `hsl(${hue},50%,75%)`;
      };

      // Takes a value, the max and min of its dataset,
      // then returns a scaled version based on a new max ands min value
      const normalizeScale = (
        valueToScale,
        datasetMin,
        datasetMax,
        newMax,
        newMin
      ) =>
        ((valueToScale - datasetMin) / (datasetMax - datasetMin)) *
          (newMax - newMin) +
        newMin;

      import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

      // Receive dataset from either local or online location
      // depending if app is deployed
      const sourceDomain = window.location.origin;
      const sourceURL =
        sourceDomain.slice(0, 5) === "https"
          ? `${sourceDomain}/data-vis-website-team7/data/dataset_v2.csv`
          : `${sourceDomain}/data/dataset_v2.csv`;
      let csvData = await $.ajax({ url: sourceURL, method: "GET" });
      let data = d3.csvParse(csvData);

      // Clean the dataset
      data = data.map((row) => {
        row["records lost"] = parseInt(row["records lost"].replace(/,/g, "")); // formatted string to int
        row["year"] = parseInt(row["year"]); // string to int
        row["data sensitivity"] = parseInt(row["data sensitivity"]); // string to int
        row["ID"] = parseInt(row["ID"]); // string to int
        row["sector"] = row["sector"] // normalize all sectors
          .trim()
          .split(", ")
          .sort()
          .join(", ")
          .trim();
        return row;
      });

      // Create a unique color pallette for the sectors
      const sectorSet = new Set();
      data.map((row) => {
        sectorSet.add(row["sector"]);
      });

      const sectorColorPallette = {};
      [...sectorSet].map((sec, i) => {
        sectorColorPallette[sec] = selectColor(i * 2);
      });

      // Grab dataset min and max to parse radius later
      const dataMin = Math.min(...data.map((row) => row["records lost"]));
      const sumOfRecordsLost = sumTheRecords(data);
      const dataMax = sumOfRecordsLost;

      // Create root node
      const treeMapData = makeNode(`${sumOfRecordsLost} Total Records lost`);

      // Bin values by the year, the record sum in root
      const binnedByYear = R.groupBy(R.prop("year"), data);
      treeMapData.value = sumOfRecordsLost;

      // Create rest of tree
      for (const [key, value] of Object.entries(binnedByYear)) {
        // Make node for each year, then record sum of the rest of the values
        const newNode = makeNode(key);
        newNode.value = sumTheRecords(value);

        // Bin children rows of year by sector
        const binnedBySector = R.groupBy(R.prop("sector"), value);

        for (const [sectorKey, value] of Object.entries(binnedBySector)) {
          // Create sector node and sum its children
          const sectorNode = makeNode(sectorKey);
          sectorNode.value = sumTheRecords(value);

          // Grab individual organisations, make a node, then add them to the sector's children
          value.map((org) => {
            const orgNode = makeNode(org.organisation);
            orgNode.value = org["records lost"];
            sectorNode.children.push(orgNode);
          });

          // Add sector to yearNode children
          newNode.children.push(sectorNode);
        }

        // Add year node to root children
        treeMapData.children.push(newNode);
      }

      /////////////////////////////////////////////////////////////////////////////////////////
      //                                  D3 Charting                                        //
      /////////////////////////////////////////////////////////////////////////////////////////
      // Chart dimensions
      data = treeMapData;
      const width = 1200;
      const marginTop = 10;
      const marginRight = 10;
      const marginBottom = 10;
      const marginLeft = 300;

      const root = d3.hierarchy(data);
      const dx = 40; // height
      const dy = (width - marginRight - marginLeft) / (1 + root.height); // width

      // Define the tree layout and the shape for links.
      const tree = d3.tree().nodeSize([dx, dy]);
      const diagonal = d3
        .linkHorizontal()
        .x((d) => d.y)
        .y((d) => d.x);

      // Create SVG
      const svg = d3
        .create("svg")
        .attr("width", width)
        .attr("height", dx)
        .attr("viewBox", [-marginLeft, -marginTop, width, dx])
        .attr(
          "style",
          "max-width: 100%; height: auto; font: 10px sans-serif; user-select: none; border: 2px solid black;"
        );
      svg.style("background-color", "#d8ecf3");

      const gLink = svg
        .append("g")
        .attr("fill", "none")
        .attr("stroke", "#212529")
        .attr("stroke-width", 1);

      const gNode = svg
        .append("g")
        .attr("cursor", "pointer")
        .attr("pointer-events", "all");

      function update(event, source) {
        const duration = 250;
        const nodes = root.descendants().reverse();
        const links = root.links();

        // Compute the new tree layout.
        tree(root);

        let left = root;
        let right = root;
        root.eachBefore((node) => {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
        });

        const height = right.x - left.x + marginTop + marginBottom;

        const transition = svg
          .transition()
          .duration(duration)
          .attr("height", height)
          .attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
          .tween(
            "resize",
            window.ResizeObserver ? null : () => () => svg.dispatch("toggle")
          );

        // Update nodes
        const node = gNode.selectAll("g").data(nodes, (d) => d.id);

        // Enter any new nodes at the parent's previous position.
        const nodeEnter = node
          .enter()
          .append("g")
          .attr("transform", (d) => `translate(${source.y0},${source.x0})`)
          .attr("fill-opacity", 0)
          .attr("stroke-opacity", 0)
          .on("click", (event, d) => {
            // Never close root
            if (d.parent) {
              const parent = d.parent;
              // Close all other nodes of parent except for self
              R.tail(parent.descendants()).forEach((child) =>
                child.id !== d.id ? (child.children = null) : null
              );
              d.children = d.children ? null : d._children;
              update(event, d);
            }
          });

        nodeEnter
          .append("circle")
          .attr("r", (d) =>
            normalizeScale(d.data.value, dataMin, dataMax, 100, 2.5)
          )
          .attr(
            "fill",
            (d) =>
              sectorColorPallette[d.data.name] ||
              sectorColorPallette[d?.parent?.data?.name] ||
              "#555"
          )
          .style("stroke", "black")
          .style("stroke-width", "1px");

        nodeEnter
          .append("text")
          .attr("dy", "0.31em")
          .attr("x", (d) => (d._children ? -6 : 6))
          .attr("text-anchor", (d) => (d._children ? "end" : "start"))
          .text((d) =>
            d._children ? d.data.name : d.data.name.concat(` | ${d.data.value}`)
          )
          .attr("stroke-linejoin", "round")
          .attr("stroke-width", 3)
          .attr("stroke", "white")
          .attr("paint-order", "stroke");

        // Transition nodes to their new position.
        const nodeUpdate = node
          .merge(nodeEnter)
          .transition(transition)
          .attr("transform", (d) => `translate(${d.y},${d.x})`)
          .attr("fill-opacity", 1)
          .attr("stroke-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        const nodeExit = node
          .exit()
          .transition(transition)
          .remove()
          .attr("transform", (d) => `translate(${source.y},${source.x})`)
          .attr("fill-opacity", 0)
          .attr("stroke-opacity", 0);

        // Update links
        const link = gLink.selectAll("path").data(links, (d) => d.target.id);

        // Enter any new links at the parent's previous position.
        const linkEnter = link
          .enter()
          .append("path")
          .attr("d", (d) => {
            const o = { x: source.x0, y: source.y0 };
            return diagonal({ source: o, target: o });
          });

        // Transition links to their new position.
        link.merge(linkEnter).transition(transition).attr("d", diagonal);

        // Transition exiting nodes to the parent's new position.
        link
          .exit()
          .transition(transition)
          .remove()
          .attr("d", (d) => {
            const o = { x: source.x, y: source.y };
            return diagonal({ source: o, target: o });
          });

        // Stash the old positions for transition.
        root.eachBefore((d) => {
          d.x0 = d.x;
          d.y0 = d.y;
        });
      }

      // Open First Node
      root.x0 = dy / 2;
      root.y0 = 0;
      root.descendants().forEach((d, i) => {
        d.id = i;
        d._children = d.children;
        if (d.depth) d.children = null;
      });

      update(null, root);

      container.append(svg.node());
    </script>
  </body>
</html>
