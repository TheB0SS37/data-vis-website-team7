<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>You've been Hacked!</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
      crossorigin="anonymous"
    />
    <link
      rel="shortcut icon"
      type="image/x-icon"
      href="./assets/computer-hacked-icon-vector.jpg?"
    />
    <link href="styles/styles.css" rel="stylesheet" />
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
      crossorigin="anonymous"
    ></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/ramda/0.20.0/ramda.min.js"></script>
  </head>
  <body data-bs-spy="scroll" data-bs-target="#navbar">
    <nav id="navbar" class="navbar navbar-dark bg-dark sticky-top">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">Team 7</a>
        <div class="bg-dark">
          <ul class="nav">
            <li class="nav-item">
              <a class="nav-link text-white" href="#elision-vis-title"
                >Elision</a
              >
            </li>
            <li class="nav-item">
              <a class="nav-link text-white" href="#circle-vis-title">Circle</a>
            </li>
            <li class="nav-item">
              <a class="nav-link text-white" href="#tableau-vis-title"
                >Tableau</a
              >
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <!------------ Intro / Summary ------------>
    <div class="d-flex flex-column text-center">
      <p class="display-1">Welcome to You've Been Hacked!</p>
      <p class="lead">
        A platform designed to help security researchers, IT administrators, and
        policymakers explore and analyze data breaches through powerful
        interactive visualizations.
      </p>
      <hr class="align-self-center hr hr-blurry w-75" />
    </div>
    <!------------ CONTENT ------------>
    <div id="elision-vis-title" class="container flex-column">
      <div class="display-3 p-3 text-center">Elision Visualization</div>
    </div>
    <div class="px-4">
      <dl class="row">
        <dt class="col-sm-3">Loading the Data</dt>
        <dd class="col-sm-9">
          Data is pre-loaded into the visualization; simply visit the page to
          start interacting.
        </dd>
        <dt class="col-sm-3">Setting Parameters</dt>
        <dd class="col-sm-9">
          No initial parameter setting is required; all nodes are collapsed to
          show only the timeline by default.
        </dd>
        <dt class="col-sm-3">Interacting with the System</dt>
        <dd class="col-sm-9">
          <p>
            Click on a year node to expand it and see detailed breaches for that
            year.
          </p>
          <p>
            Click on a sector within a year to view specific companies and
            further details on breaches.
          </p>
          <p>
            Use mouse wheel or pinch-to-zoom on mobile to zoom in and out of
            specific areas of the chart.
          </p>
        </dd>
        <dt class="col-sm-3">Resetting the View</dt>
        <dd class="col-sm-9">
          Double-click on the background or use the 'Reset' button to return to
          the initial overview.
        </dd>
      </dl>
    </div>
    <!--Elision container-->
    <div id="container" class="d-flex flex-row justify-content-center"></div>
    <div
      id="circle-vis-title"
      class="container d-flex flex-row justify-content-center"
    >
      <div class="display-3 p-3">Circle Visualization</div>
    </div>
    <!--Circle container-->
    <div class="px-4">
      <dl class="row">
        <dt class="col-sm-3">Loading the Data</dt>
        <dd class="col-sm-9">
          Automatically loads with the visualization; just open the
          visualization page.
        </dd>
        <dt class="col-sm-3">Setting Parameters</dt>
        <dd class="col-sm-9">
          No setup needed; the visualization starts with an overview of all
          sectors.
        </dd>
        <dt class="col-sm-3">Interacting with the System</dt>
        <dd class="col-sm-9">
          <p>Hover over any sector to see a tooltip with summary statistics.</p>
          <p>
            Click on a sector to zoom into detailed views of companies affected
            by breaches within that sector.
          </p>
        </dd>
        <dt class="col-sm-3">Resetting the View</dt>
        <dd class="col-sm-9">
          Click on the visualization to reset the zoom level and view all
          sectors simultaneously.
        </dd>
      </dl>
    </div>
    <div class="d-flex justify-content-center">
      <select id="circleFilter" class="form-select">
        <option value="sector">Filter by Sector</option>
        <option value="method">Filter by Method of Hack</option>
        <option value="month">Filter by Month</option>
      </select>
    </div>
    <div
      id="circleContainer"
      class="d-flex flex-row justify-content-center"
    ></div>
    <div id="circleLegend" class="d-flex text-center m-auto">
      <div class="card w-100" style="background-color: #83a7fb">
        <p class="p-0 m-0">Number of Records Lost</p>
        <div class="d-flex justify-content-between px-3">
          <p id="circleLegendMin" class="legendText">Min</p>
          <div class="d-flex align-items-center">
            <div id="legendCircle1"></div>
            <div id="legendCircle2"></div>
            <div id="legendCircle3"></div>
            <div id="legendCircle4"></div>
          </div>
          <p id="circleLegendMax" class="legendText">Max</p>
        </div>
      </div>
    </div>
    <div
      id="tableau-vis-title"
      class="container d-flex flex-row justify-content-center"
    >
      <div class="display-3 p-3">Tableau Visualization</div>
    </div>
    <div class="px-4">
      <dl class="row">
        <dt class="col-sm-3">Loading the Data</dt>
        <dd class="col-sm-9">
          The dashboard loads automatically with embedded data when accessed.
        </dd>
        <dt class="col-sm-3">Setting Parameters</dt>
        <dd class="col-sm-9">No setup needed.</dd>
        <dt class="col-sm-3">Interacting with the System</dt>
        <dd class="col-sm-9">
          <p>
            Click on any bar or sector in the charts to filter other sections of
            the dashboard accordingly.
          </p>
          <p>
            Hover over chart elements to display tooltips with detailed
            information.
          </p>
          <p>
            Use the 'Explore details' links to access deeper analytics on each
            chart.
          </p>
        </dd>
        <dt class="col-sm-3">Resetting the View</dt>
        <dd class="col-sm-9">
          To clear all selections and start over, click on the 'Reset' link
          usually found at the bottom of the dashboard
        </dd>
      </dl>
    </div>
    <!-- Tableau Vis Embed -->
    <div class="container-fluid d-flex flex-row justify-content-center">
      <div
        class="tableauPlaceholder col-4"
        id="viz1714701799345"
        style="position: relative"
      >
        <noscript
          ><a href="#"
            ><img
              alt="Main Dash "
              src="https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;MH&#47;MHN389JCC&#47;1_rss.png"
              style="border: none" /></a></noscript
        ><object class="tableauViz" style="display: none">
          <param name="host_url" value="https%3A%2F%2Fpublic.tableau.com%2F" />
          <param name="embed_code_version" value="3" />
          <param name="path" value="shared&#47;MHN389JCC" />
          <param name="toolbar" value="yes" />
          <param
            name="static_image"
            value="https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;MH&#47;MHN389JCC&#47;1.png"
          />
          <param name="animate_transition" value="yes" />
          <param name="display_static_image" value="yes" />
          <param name="display_spinner" value="yes" />
          <param name="display_overlay" value="yes" />
          <param name="display_count" value="yes" />
          <param name="language" value="en-US" />
        </object>
      </div>
      <script type="text/javascript">
        var divElement = document.getElementById("viz1714701799345");
        var vizElement = divElement.getElementsByTagName("object")[0];
        if (divElement.offsetWidth > 800) {
          vizElement.style.width = "1200px";
          vizElement.style.height = "827px";
        } else if (divElement.offsetWidth > 500) {
          vizElement.style.width = "1200px";
          vizElement.style.height = "827px";
        } else {
          vizElement.style.width = "100%";
          vizElement.style.height = "2327px";
        }
        var scriptElement = document.createElement("script");
        scriptElement.src =
          "https://public.tableau.com/javascripts/api/viz_v1.js";
        vizElement.parentNode.insertBefore(scriptElement, vizElement);
      </script>
    </div>
    <!-- End Tableau vis embed -->

    <!------------ JS  ------------>
    <script type="module">
      // D3 Vis /////////////////////////

      // Create node data structure. Children contains other nodes
      const makeNode = (name) => {
        return { name: name, children: [] };
      };

      // Receives an array of row objects and returns the sum of records lost
      const sumTheRecords = (data = []) => {
        return data.reduce((sum, row) => sum + row["records lost"], 0);
      };

      // Creates a unique color based on an index approximation of golden angle
      const selectColor = (number) => {
        const hue = number * 137.508;
        return `hsl(${hue},50%,75%)`;
      };

      // Takes a value, the max and min of its dataset,
      // then returns a scaled version based on a new max ands min value
      const normalizeScale = (
        valueToScale,
        datasetMin,
        datasetMax,
        newMax,
        newMin
      ) =>
        ((valueToScale - datasetMin) / (datasetMax - datasetMin)) *
          (newMax - newMin) +
        newMin;

      import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

      // Receive dataset from either local or online location
      // depending if app is deployed
      const sourceDomain = window.location.origin;
      const sourceURL =
        sourceDomain.slice(0, 5) === "https"
          ? `${sourceDomain}/data-vis-website-team7/data/dataset_v4.csv`
          : `${sourceDomain}/data/dataset_v4.csv`;
      let csvData = await $.ajax({ url: sourceURL, method: "GET" });
      let myData = d3.csvParse(csvData);

      // Clean the dataset
      myData = myData.map((row) => {
        row["records lost"] = parseInt(row["records lost"].replace(/,/g, "")); // formatted string to int
        row["year"] = parseInt(row["year"]); // string to int
        row["data sensitivity"] = parseInt(row["data sensitivity"]); // string to int
        row["ID"] = parseInt(row["ID"]); // string to int
        row["sector"] = row["sector"] // normalize all sectors
          .trim()
          .split(", ")
          .sort()
          .join(", ")
          .trim();
        return row;
      });

      // Create a unique color pallette for the sectors
      const sectorSet = new Set();
      myData.map((row) => {
        sectorSet.add(row["sector"]);
      });

      const sectorColorPallette = {};
      [...sectorSet].map((sec, i) => {
        sectorColorPallette[sec] = selectColor(i * 2);
      });

      const formatter = new Intl.NumberFormat("en-US", { notation: "compact" });

      // Grab dataset min and max to parse radius later
      const dataMin = Math.min(...myData.map((row) => row["records lost"]));
      const sumOfRecordsLost = sumTheRecords(myData);
      const dataMax = sumOfRecordsLost;
      const treeYearSectorOrg = (data) => {
        // Create root node
        const treeMapData = makeNode(
          `${formatter.format(sumOfRecordsLost)} Total Records lost`
        );

        // Bin values by the year, the record sum in root
        const binnedByYear = R.groupBy(R.prop("year"), data);
        treeMapData.value = sumOfRecordsLost;

        // Create rest of tree
        for (const [key, value] of Object.entries(binnedByYear)) {
          // Make node for each year, then record sum of the rest of the values
          const newNode = makeNode(key);
          newNode.value = sumTheRecords(value);

          // Bin children rows of year by sector
          const binnedBySector = R.groupBy(R.prop("sector"), value);

          for (const [sectorKey, value] of Object.entries(binnedBySector)) {
            // Create sector node and sum its children
            const sectorNode = makeNode(sectorKey);
            sectorNode.value = sumTheRecords(value);

            // Grab individual organisations, make a node, then add them to the sector's children
            value.map((org) => {
              const orgNode = makeNode(org.organisation);
              orgNode.value = org["records lost"];
              orgNode.story = org["story"];
              sectorNode.children.push(orgNode);
            });

            // Add sector to yearNode children
            newNode.children.push(sectorNode);
          }

          // Add year node to root children
          treeMapData.children.push(newNode);
        }
        return treeMapData;
      };

      const treePropOrg = (data, prop) => {
        // Create root node
        const treeMapData = makeNode(
          `${formatter.format(sumOfRecordsLost)} Total Records lost`
        );

        // Bin values by the year, the record sum in root
        const binnedByProp = R.groupBy(R.prop(prop), data);
        treeMapData.value = sumOfRecordsLost;

        // Create rest of tree
        for (const [propKey, value] of Object.entries(binnedByProp)) {
          // Make node for each year, then record sum of the rest of the values
          const propNode = makeNode(propKey);
          propNode.value = sumTheRecords(value);

          // Grab individual organisations, make a node, then add them to the props's children
          value.map((org) => {
            const orgNode = makeNode(org.organisation);
            orgNode.value = org["records lost"];
            orgNode.story = org["story"];
            propNode.children.push(orgNode);
          });
          treeMapData.children.push(propNode);
        }

        // Add year node to root children
        return treeMapData;
      };

      /////////////////////////////////////////////////////////////////////////////////////////
      //                                  D3 Charting                                        //
      /////////////////////////////////////////////////////////////////////////////////////////
      /////////////////////////////////////////////////////////////////////////////////////////
      //                                    Elision                                          //
      /////////////////////////////////////////////////////////////////////////////////////////
      const updateElision = (data) => {
        $("#container").find("svg").remove();
        // Chart dimensions
        const width = 1200;
        const marginTop = 20;
        const marginRight = 10;
        const marginBottom = 20;
        const marginLeft = 300;

        const root = d3.hierarchy(data);
        const dx = 72; // height
        const dy = (width - marginRight - marginLeft) / (1 + root.height); // width

        // Define the tree layout and the shape for links.
        const tree = d3.tree().nodeSize([dx, dy]);
        const diagonal = d3
          .linkHorizontal()
          .x((d) => d.y)
          .y((d) => d.x);

        // Create SVG
        const svg = d3
          .create("svg")
          .attr("width", width)
          .attr("height", dx)
          .attr("viewBox", [-marginLeft, -marginTop, width, dx])
          .attr(
            "style",
            "max-width: 100%; height: auto; font: 16px sans-serif; user-select: none; border: 2px solid black;"
          );
        svg.style("background-color", "#d8ecf3");

        const gLink = svg
          .append("g")
          .attr("fill", "none")
          .attr("stroke", "#212529")
          .attr("stroke-width", 1);

        const gNode = svg
          .append("g")
          .attr("cursor", "pointer")
          .attr("pointer-events", "all");

        function update(event, source) {
          const duration = 250;
          const nodes = root.descendants().reverse();
          const links = root.links();

          // Compute the new tree layout.
          tree(root);

          let left = root;
          let right = root;
          root.eachBefore((node) => {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
          });

          let height = right.x - left.x + marginTop + marginBottom;

          const transition = svg
            .transition()
            .duration(duration)
            .attr("height", height)
            .attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
            .tween(
              "resize",
              window.ResizeObserver ? null : () => () => svg.dispatch("toggle")
            );

          // Update nodes
          const node = gNode.selectAll("g").data(nodes, (d) => d.id);

          var div = d3
            .select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

          function getOffset(el) {
            const rect = el.getBoundingClientRect();
            return {
              left: rect.left + window.scrollX,
              top: rect.top + window.scrollY,
            };
          }

          // Enter any new nodes at the parent's previous position.
          const nodeEnter = node
            .enter()
            .append("g")
            .attr("transform", (d) => `translate(${source.y0},${source.x0})`)
            .attr("fill-opacity", 0)
            .attr("stroke-opacity", 0)
            .on("click", (event, d) => {
              // Never close root
              if (d.parent) {
                if (d._children) {
                  const parent = d.parent;
                  // Close all other nodes of parent except for self
                  R.tail(parent.descendants()).forEach((child) =>
                    child.id !== d.id ? (child.children = null) : null
                  );
                  d.children = d.children ? null : d._children;
                  update(event, d);
                } else if (d.data.story) {
                  let storyModal = document.getElementById("storyModal");

                  if (!storyModal) {
                    const modalContent = `<div class="modal fade" id="storyModal" tabindex="-1" aria-labelledby="storyModalLabel" aria-hidden="true">
                          <div class="modal-dialog modal-dialog-centered">
                              <div class="modal-content">
                                  <div class="modal-header">
                                      <h5 class="modal-title">${
                                        d.data.name
                                      } - ${formatter.format(
                      d.data.value
                    )} records affected</h5>
                                      <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                  </div>
                                  <div class="modal-body">
                                      ${d.data.story}
                                  </div>
                              </div>
                          </div>
                      </div>`;

                    document.body.insertAdjacentHTML("beforeend", modalContent);

                    storyModal = new bootstrap.Modal(
                      document.getElementById("storyModal")
                    );
                    storyModal.show();
                  } else {
                    const modalTitle = storyModal.querySelector(".modal-title");
                    const modalBody = storyModal.querySelector(".modal-body");

                    modalTitle.innerText = `${d.data.name} - ${formatter.format(
                      d.data.value
                    )} records affected`;
                    modalBody.innerText = d.data.story;

                    const modalInstance =
                      bootstrap.Modal.getInstance(storyModal);
                    modalInstance.show();
                  }
                }
              }
            })
            .on("mouseover", function (event, d) {
              if (!d._children) {
                div.transition().duration(500).style("opacity", 1);
                div
                  .html("<h6>Click to read story</h6>")
                  .style("left", getOffset(this).left + 40 + "px")
                  .style("top", getOffset(this).top + 40 + "px")
                  .style("background-color", "white");
              }
            })
            .on("mouseout", (d) => {
              div.transition().duration(500).style("opacity", 0);
            });

          nodeEnter
            .append("circle")
            .attr("r", (d) =>
              normalizeScale(
                Math.sqrt(d.data.value),
                Math.sqrt(dataMin),
                Math.sqrt(dataMax),
                80,
                2.5
              )
            )
            .attr(
              "fill",
              (d) =>
                sectorColorPallette[d.data.name] ||
                sectorColorPallette[d?.parent?.data?.name] ||
                "#555"
            )
            .style("stroke", "black")
            .style("stroke-width", "1px");

          nodeEnter
            .append("text")
            .attr("dy", "0.31em")
            .attr("x", (d) => (d.depth == 0 ? 31 : d._children ? -6 : 6))
            .attr("text-anchor", (d) => (d._children ? "end" : "start"))
            .text((d) =>
              d._children
                ? d.data.name
                : d.data.name.concat(` | ${formatter.format(d.data.value)}`)
            )
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 3)
            .attr("stroke", "white")
            .attr("paint-order", "stroke");

          // Transition nodes to their new position.
          const nodeUpdate = node
            .merge(nodeEnter)
            .transition(transition)
            .attr("transform", (d) => `translate(${d.y},${d.x})`)
            .attr("fill-opacity", 1)
            .attr("stroke-opacity", 1);

          // Transition exiting nodes to the parent's new position.
          const nodeExit = node
            .exit()
            .transition(transition)
            .remove()
            .attr("transform", (d) => `translate(${source.y},${source.x})`)
            .attr("fill-opacity", 0)
            .attr("stroke-opacity", 0);

          // Update links
          const link = gLink.selectAll("path").data(links, (d) => d.target.id);

          // Enter any new links at the parent's previous position.
          const linkEnter = link
            .enter()
            .append("path")
            .attr("d", (d) => {
              const o = { x: source.x0, y: source.y0 };
              return diagonal({ source: o, target: o });
            });

          // Transition links to their new position.
          link.merge(linkEnter).transition(transition).attr("d", diagonal);

          // Transition exiting nodes to the parent's new position.
          link
            .exit()
            .transition(transition)
            .remove()
            .attr("d", (d) => {
              const o = { x: source.x, y: source.y };
              return diagonal({ source: o, target: o });
            });

          // Stash the old positions for transition.
          root.eachBefore((d) => {
            d.x0 = d.x;
            d.y0 = d.y;
          });
        }

        // Open First Node
        root.x0 = dy / 2;
        root.y0 = 0;
        root.descendants().forEach((d, i) => {
          d.id = i;
          d._children = d.children;
          if (d.depth) d.children = null;
        });

        update(null, root);

        container.append(svg.node());
      };
      /////////////////////////////////////////////////////////////////////////////////////////
      //                                 </ Elision>                                         //
      /////////////////////////////////////////////////////////////////////////////////////////
      /////////////////////////////////////////////////////////////////////////////////////////
      //                                  Circle Packing                                     //
      /////////////////////////////////////////////////////////////////////////////////////////
      const updateCirclePack = (data) => {
        $("#circleContainer").find("svg").remove();
        // Specify the chart’s dimensions.
        const width = 928;
        const height = width;

        // Create the color scale.
        const color = d3
          .scaleLinear()
          .domain([0, 5])
          .range(["#FFCB2E", "#FFFFFA"])
          .interpolate(d3.interpolateHcl);

        // Compute the layout.
        const pack = (data) =>
          d3.pack().size([width, height]).padding(3)(
            d3
              .hierarchy(data)
              .sum((d) => d.value)
              .sort((a, b) => b.value - a.value)
          );
        const root = pack(data);

        // Create the SVG container.
        const svg = d3
          .create("svg")
          .attr("viewBox", `-${width / 2} -${height / 2} ${width} ${height}`)
          .attr("width", width)
          .attr("height", height)
          .attr(
            "style",
            `max-width: 100%; height: auto; display: block; margin: 0 -14px; background: #83a7fb; cursor: pointer;`
          );

        const colorScale = d3.scaleSequential(d3.interpolateOranges);
        let focus = root;
        let clickedNode = null;
        // Append the nodes.
        let node = svg
          .append("g")
          .selectAll("circle")
          .data(root.descendants().slice(1))
          .join("circle")
          .attr("fill", (d) =>
            d.children
              ? color(d.depth)
              : colorScale(
                  normalizeScale(
                    d.data.value,
                    0,
                    Math.max(...d.parent.children.map((row) => row.data.value)),
                    0,
                    1
                  )
                )
          )
          .attr("pointer-events", (d) => (!d.children ? "none" : null))
          .on("mouseover", function (event, d) {
            d3.select(this).attr("stroke", "#000");
            label.style("fill-opacity", (nd) =>
              nd.data.name ===
              d3.select(this)["_groups"][0][0]["__data__"].data.name
                ? 1
                : (nd.parent === root && clickedNode !== nd) ||
                  (nd.parent === focus &&
                    Math.sqrt(nd.r) / Math.sqrt(nd.parent.r) > 0.4)
                ? 1
                : 0
            );
          })
          .on("mouseout", function () {
            d3.select(this).attr("stroke", null);
          })
          .on("click", (event, d) => {
            if (!d.children) {
              // Do not zoom into organization node
              event.stopPropagation();
              return;
            }

            const nodeMin = Math.min(
              ...d.children.map((row) => row.data.value)
            );
            const nodeMax = Math.max(
              ...d.children.map((row) => row.data.value)
            );
            $("#circleLegendMin").text(formatter.format(nodeMin));
            $("#circleLegendMax").text(formatter.format(nodeMax));
            // Update the focus to the clicked node
            clickedNode = d;
            // Update pointer-events for nodes
            node.attr("pointer-events", (nd) => {
              return nd.parent === clickedNode ? "all" : "none";
            });

            focus !== d && (zoom(event, d), event.stopPropagation());
          });

        // Append the text labels.
        const label = svg
          .append("g")
          .style("font", "20px sans-serif")
          .attr("pointer-events", "none")
          .attr("text-anchor", "middle")
          .selectAll("text")
          .data(root.descendants())
          .join("text")
          .style("fill-opacity", (d) => (d.parent === root ? 1 : 0))
          .style("display", (d) => (d.parent === root ? "inline" : "none"))
          .text((d) => d.data.name);

        // Create the zoom behavior and zoom immediately in to the initial focus node
        svg.on("click", (event) => {
          $("#circleLegendMin").text("Min");
          $("#circleLegendMax").text("Max");

          // Only want root nodes to be clickable again
          node.attr("pointer-events", (d) =>
            d.parent === root ? null : "none"
          );
          zoom(event, root);
        });
        let view;
        zoomTo([focus.x, focus.y, focus.r * 2 + 100]);

        function zoomTo(v) {
          const k = width / v[2];

          view = v;

          label.attr(
            "transform",
            (d) => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`
          );
          node.attr(
            "transform",
            (d) => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`
          );
          node.attr("r", (d) => d.r * k);
        }

        function zoom(event, d) {
          const focus0 = focus;

          focus = d;

          const transition = svg
            .transition()
            .duration(800)
            .tween("zoom", (d) => {
              const i = d3.interpolateZoom(view, [
                focus.x,
                focus.y,
                focus.r * 2 + 100,
              ]);
              return (t) => zoomTo(i(t));
            });

          label
            .filter(function (d) {
              return d.parent === focus || this.style.display === "inline";
            })
            .transition(transition)
            .style("fill-opacity", (d) =>
              (d.parent === root && clickedNode !== d) ||
              (d.parent === focus &&
                Math.sqrt(d.r) / Math.sqrt(d.parent.r) > 0.4)
                ? 1
                : 0
            )
            .on("start", function (d) {
              if (d.parent === focus) this.style.display = "inline";
            })
            .on("end", function (d) {
              if (d.parent !== focus) this.style.display = "none";
            });
        }

        circleContainer.append(svg.node());
      };

      const treeMapData = treeYearSectorOrg(myData);
      // JQuery stuff
      $(document).ready(function () {
        updateElision(treeMapData);
        updateCirclePack(treePropOrg(myData, $("#circleFilter").val()));

        $("#circleFilter").change(function (event) {
          $("#circleLegendMin").text("Min");
          $("#circleLegendMax").text("Max");
          updateCirclePack(treePropOrg(myData, event.target.value));
        });
      });
    </script>
  </body>
</html>
