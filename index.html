<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>You've been Hacked!</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC"
      crossorigin="anonymous"
    />
    <link
      rel="icon"
      type="image/x-icon"
      href="/assets/computer-hacked-icon-vector.jpg"
    />
    <link href="styles.css" rel="stylesheet" />
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/ramda/0.20.0/ramda.min.js"></script>
  </head>
  <body>
    <div class="container d-flex flex-row justify-content-center">
      <div class="display-1">Hacked!</div>
    </div>
    <!DOCTYPE html>
    <div id="container" class="d-flex flex-row justify-content-center"></div>
    <script type="module">
      // D3 Test
      const makeNode = (name) => {
        return { name: name, children: [] };
      };

      const sumTheRecords = (data = []) => {
        return data.reduce((sum, row) => sum + row["records lost"], 0);
      };

      import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
      const sourceDomain = window.location.origin;
      const sourceURL =
        sourceDomain.slice(0, 5) === "https"
          ? `${sourceDomain}/data-vis-website-team7/data/EDA-dataset.csv`
          : `${sourceDomain}/data/EDA-dataset.csv`;
      let csvData = await $.ajax({ url: sourceURL, method: "GET" });
      let data = d3.csvParse(csvData);

      data = data.map((row) => {
        row["records lost"] = parseInt(row["records lost"].replace(/,/g, ""));
        row["year"] = parseInt(row["year"]);
        row["data sensitivity"] = parseInt(row["data sensitivity"]);
        row["ID"] = parseInt(row["ID"]);
        row["sector"] = row["sector"].trim();
        return row;
      });

      const dataMin = Math.min(...data.map((row) => row["records lost"]));

      const sumOfRecordsLost = sumTheRecords(data);
      const dataMax = sumOfRecordsLost;

      const binnedByYear = R.groupBy(R.prop("year"), data);
      const treeMapData = makeNode(`${sumOfRecordsLost} Total Records lost`);
      treeMapData.value = sumOfRecordsLost;
      for (const [key, value] of Object.entries(binnedByYear)) {
        const newNode = makeNode(key);
        newNode.value = sumTheRecords(value);
        const binnedBySector = R.groupBy(R.prop("sector"), value);

        for (const [sectorKey, value] of Object.entries(binnedBySector)) {
          const sectorNode = makeNode(sectorKey);
          sectorNode.value = sumTheRecords(value);
          value.map((org) => {
            const orgNode = makeNode(org.organisation);
            orgNode.value = org["records lost"];
            sectorNode.children.push(orgNode);
          });
          newNode.children.push(sectorNode);
        }

        treeMapData.children.push(newNode);
      }

      /////////////////////////////////////////////////////////////////////////////////////////
      /////////////////////////////////////////////////////////////////////////////////////////
      // Specify the charts’ dimensions. The height is variable, depending on the layout.
      data = treeMapData;
      const width = 928;
      const marginTop = 10;
      const marginRight = 10;
      const marginBottom = 10;
      const marginLeft = 300;

      // Rows are separated by dx pixels, columns by dy pixels. These names can be counter-intuitive
      // (dx is a height, and dy a width). This because the tree must be viewed with the root at the
      // “bottom”, in the data domain. The width of a column is based on the tree’s height.
      const root = d3.hierarchy(data);
      const dx = 40;
      const dy = (width - marginRight - marginLeft) / (1 + root.height);

      // Define the tree layout and the shape for links.
      const tree = d3.tree().nodeSize([dx, dy]);
      const diagonal = d3
        .linkHorizontal()
        .x((d) => d.y)
        .y((d) => d.x);

      // Create the SVG container, a layer for the links and a layer for the nodes.
      const svg = d3
        .create("svg")
        .attr("width", width)
        .attr("height", dx)
        .attr("viewBox", [-marginLeft, -marginTop, width, dx])
        .attr(
          "style",
          "max-width: 100%; height: auto; font: 10px sans-serif; user-select: none;"
        );

      const gLink = svg
        .append("g")
        .attr("fill", "none")
        .attr("stroke", "#555")
        .attr("stroke-opacity", 0.4)
        .attr("stroke-width", 1.5);

      const gNode = svg
        .append("g")
        .attr("cursor", "pointer")
        .attr("pointer-events", "all");

      function update(event, source) {
        const duration = event?.altKey ? 2500 : 250; // hold the alt key to slow down the transition
        const nodes = root.descendants().reverse();
        const links = root.links();

        // Compute the new tree layout.
        tree(root);

        let left = root;
        let right = root;
        root.eachBefore((node) => {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
        });

        const height = right.x - left.x + marginTop + marginBottom;

        const transition = svg
          .transition()
          .duration(duration)
          .attr("height", height)
          .attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
          .tween(
            "resize",
            window.ResizeObserver ? null : () => () => svg.dispatch("toggle")
          );

        // Update the nodes…
        const node = gNode.selectAll("g").data(nodes, (d) => d.id);

        // Enter any new nodes at the parent's previous position.
        const nodeEnter = node
          .enter()
          .append("g")
          .attr("transform", (d) => `translate(${source.y0},${source.x0})`)
          .attr("fill-opacity", 0)
          .attr("stroke-opacity", 0)
          .on("click", (event, d) => {
            d.children = d.children ? null : d._children;
            update(event, d);
          });

        nodeEnter
          .append("circle")
          .attr(
            "r",
            (d) =>
              ((d.data.value - dataMin) / (dataMax - dataMin)) * (100 - 2.5) +
              2.5
          )
          .attr("fill", (d) => (d._children ? "#555" : "#999"))
          .attr("stroke-width", 10);

        nodeEnter
          .append("text")
          .attr("dy", "0.31em")
          .attr("x", (d) => (d._children ? -6 : 6))
          .attr("text-anchor", (d) => (d._children ? "end" : "start"))
          .text((d) => d.data.name)
          .attr("stroke-linejoin", "round")
          .attr("stroke-width", 3)
          .attr("stroke", "white")
          .attr("paint-order", "stroke");

        // Transition nodes to their new position.
        const nodeUpdate = node
          .merge(nodeEnter)
          .transition(transition)
          .attr("transform", (d) => `translate(${d.y},${d.x})`)
          .attr("fill-opacity", 1)
          .attr("stroke-opacity", 1);

        // Transition exiting nodes to the parent's new position.
        const nodeExit = node
          .exit()
          .transition(transition)
          .remove()
          .attr("transform", (d) => `translate(${source.y},${source.x})`)
          .attr("fill-opacity", 0)
          .attr("stroke-opacity", 0);

        // Update the links…
        const link = gLink.selectAll("path").data(links, (d) => d.target.id);

        // Enter any new links at the parent's previous position.
        const linkEnter = link
          .enter()
          .append("path")
          .attr("d", (d) => {
            const o = { x: source.x0, y: source.y0 };
            return diagonal({ source: o, target: o });
          });

        // Transition links to their new position.
        link.merge(linkEnter).transition(transition).attr("d", diagonal);

        // Transition exiting nodes to the parent's new position.
        link
          .exit()
          .transition(transition)
          .remove()
          .attr("d", (d) => {
            const o = { x: source.x, y: source.y };
            return diagonal({ source: o, target: o });
          });

        // Stash the old positions for transition.
        root.eachBefore((d) => {
          d.x0 = d.x;
          d.y0 = d.y;
        });
      }

      // Do the first update to the initial configuration of the tree — where a number of nodes
      // are open (arbitrarily selected as the root, plus nodes with 7 letters).
      root.x0 = dy / 2;
      root.y0 = 0;
      root.descendants().forEach((d, i) => {
        d.id = i;
        d._children = d.children;
        if (d.depth && d.data.name.length !== 7) d.children = null;
      });

      update(null, root);

      container.append(svg.node());
    </script>
  </body>
</html>
