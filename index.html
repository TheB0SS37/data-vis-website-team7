<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>You've been Hacked!</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3"
      crossorigin="anonymous"
    />
    <link
      rel="shortcut icon"
      type="image/x-icon"
      href="./assets/computer-hacked-icon-vector.jpg?"
    />
    <link href="styles.css" rel="stylesheet" />
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p"
      crossorigin="anonymous"
    ></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/ramda/0.20.0/ramda.min.js"></script>
  </head>
  <body data-bs-spy="scroll" data-bs-target="#navbar">
    <nav id="navbar" class="navbar navbar-dark bg-dark sticky-top">
      <div class="container-fluid">
        <a class="navbar-brand" href="#">Team 7</a>
        <div class="bg-dark">
          <ul class="nav">
            <li class="nav-item">
              <a class="nav-link text-white" href="#">Elision</a>
            </li>
            <li class="nav-item">
              <a class="nav-link text-white" href="#circle-vis-title">Circle</a>
            </li>
            <li class="nav-item">
              <a class="nav-link text-white" href="#tableau-vis-title"
                >Tableau</a
              >
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <!------------ CONTENT ------------>

    <div
      id="hierarchy-vis-title"
      class="container d-flex flex-row justify-content-center"
    >
      <div class="display-3 p-3">Elision Visualization</div>
    </div>
    <!--Elision container-->
    <div id="container" class="d-flex flex-row justify-content-center"></div>
    <div
      id="circle-vis-title"
      class="container d-flex flex-row justify-content-center"
    >
      <div class="display-3 p-3">Circle Visualization</div>
    </div>
    <!--Circle container-->
    <div
      id="circleContainer"
      class="d-flex flex-row justify-content-center"
    ></div>
    <div
      id="tableau-vis-title"
      class="container d-flex flex-row justify-content-center"
    >
      <div class="display-3 p-3">Tableau Visualization</div>
    </div>
    <!-- Tableau Vis Embed -->
    <div class="container d-flex flex-row justify-content-center">
      <div
        class="tableauPlaceholder"
        id="viz1712443739207"
        style="position: relative"
      >
        <noscript
          ><a href="#"
            ><img
              alt="Dashboard 1 "
              src="https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;5X&#47;5X95ZB3RZ&#47;1_rss.png"
              style="border: none" /></a></noscript
        ><object
          class="tableauViz"
          style="display: none; margin-left: auto; margin-right: auto"
        >
          <param name="host_url" value="https%3A%2F%2Fpublic.tableau.com%2F" />
          <param name="embed_code_version" value="3" />
          <param
            name="path"
            value="views&#47;ProjectDashboard3_17123298610860&#47;Dashboard1?:language=en-US&amp;:embed=true&amp;:sid="
          />
          <param name="toolbar" value="yes" />
          <param
            name="static_image"
            value="https:&#47;&#47;public.tableau.com&#47;static&#47;images&#47;5X&#47;5X95ZB3RZ&#47;1.png"
          />
          <param name="animate_transition" value="yes" />
          <param name="display_static_image" value="yes" />
          <param name="display_spinner" value="yes" />
          <param name="display_overlay" value="yes" />
          <param name="display_count" value="yes" />
          <param name="language" value="en-US" />
        </object>
      </div>
    </div>
    <script type="text/javascript">
      var divElement = document.getElementById("viz1712443739207");
      var vizElement = divElement.getElementsByTagName("object")[0];

      vizElement.style.maxWidth = "1100px";
      vizElement.style.width = "100%";
      vizElement.style.minHeight = "587px";
      vizElement.style.maxHeight = "1277px";

      var scriptElement = document.createElement("script");
      scriptElement.src =
        "https://public.tableau.com/javascripts/api/viz_v1.js";
      vizElement.parentNode.insertBefore(scriptElement, vizElement);
    </script>
    <!-- End Tableau vis embed -->

    <!------------ JS  ------------>
    <script type="module">
      // D3 Vis /////////////////////////

      // Create node data structure. Children contains other nodes
      const makeNode = (name) => {
        return { name: name, children: [] };
      };

      // Receives an array of row objects and returns the sum of records lost
      const sumTheRecords = (data = []) => {
        return data.reduce((sum, row) => sum + row["records lost"], 0);
      };

      // Creates a unique color based on an index approximation of golden angle
      const selectColor = (number) => {
        const hue = number * 137.508;
        return `hsl(${hue},50%,75%)`;
      };

      // Takes a value, the max and min of its dataset,
      // then returns a scaled version based on a new max ands min value
      const normalizeScale = (
        valueToScale,
        datasetMin,
        datasetMax,
        newMax,
        newMin
      ) =>
        ((valueToScale - datasetMin) / (datasetMax - datasetMin)) *
          (newMax - newMin) +
        newMin;

      import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

      // Receive dataset from either local or online location
      // depending if app is deployed
      const sourceDomain = window.location.origin;
      const sourceURL =
        sourceDomain.slice(0, 5) === "https"
          ? `${sourceDomain}/data-vis-website-team7/data/dataset_v2.csv`
          : `${sourceDomain}/data/dataset_v2.csv`;
      let csvData = await $.ajax({ url: sourceURL, method: "GET" });
      let data = d3.csvParse(csvData);

      // Clean the dataset
      data = data.map((row) => {
        row["records lost"] = parseInt(row["records lost"].replace(/,/g, "")); // formatted string to int
        row["year"] = parseInt(row["year"]); // string to int
        row["data sensitivity"] = parseInt(row["data sensitivity"]); // string to int
        row["ID"] = parseInt(row["ID"]); // string to int
        row["sector"] = row["sector"] // normalize all sectors
          .trim()
          .split(", ")
          .sort()
          .join(", ")
          .trim();
        return row;
      });

      // Create a unique color pallette for the sectors
      const sectorSet = new Set();
      data.map((row) => {
        sectorSet.add(row["sector"]);
      });

      const sectorColorPallette = {};
      [...sectorSet].map((sec, i) => {
        sectorColorPallette[sec] = selectColor(i * 2);
      });

      const formatter = new Intl.NumberFormat("en-US", { notation: "compact" });

      // Grab dataset min and max to parse radius later
      const dataMin = Math.min(...data.map((row) => row["records lost"]));
      const sumOfRecordsLost = sumTheRecords(data);
      const dataMax = sumOfRecordsLost;

      // Create root node
      const treeMapData = makeNode(
        `${formatter.format(sumOfRecordsLost)} Total Records lost`
      );

      // Bin values by the year, the record sum in root
      const binnedByYear = R.groupBy(R.prop("year"), data);
      treeMapData.value = sumOfRecordsLost;

      // Create rest of tree
      for (const [key, value] of Object.entries(binnedByYear)) {
        // Make node for each year, then record sum of the rest of the values
        const newNode = makeNode(key);
        newNode.value = sumTheRecords(value);

        // Bin children rows of year by sector
        const binnedBySector = R.groupBy(R.prop("sector"), value);

        for (const [sectorKey, value] of Object.entries(binnedBySector)) {
          // Create sector node and sum its children
          const sectorNode = makeNode(sectorKey);
          sectorNode.value = sumTheRecords(value);

          // Grab individual organisations, make a node, then add them to the sector's children
          value.map((org) => {
            const orgNode = makeNode(org.organisation);
            orgNode.value = org["records lost"];
            orgNode.story = org["story"];
            sectorNode.children.push(orgNode);
          });

          // Add sector to yearNode children
          newNode.children.push(sectorNode);
        }

        // Add year node to root children
        treeMapData.children.push(newNode);
      }

      /////////////////////////////////////////////////////////////////////////////////////////
      //                                  D3 Charting                                        //
      /////////////////////////////////////////////////////////////////////////////////////////
      /////////////////////////////////////////////////////////////////////////////////////////
      //                                    Elision                                          //
      /////////////////////////////////////////////////////////////////////////////////////////
      const updateElision = (data) => {
        // Chart dimensions
        const width = 1200;
        const marginTop = 10;
        const marginRight = 10;
        const marginBottom = 10;
        const marginLeft = 300;

        const root = d3.hierarchy(data);
        const dx = 40; // height
        const dy = (width - marginRight - marginLeft) / (1 + root.height); // width

        // Define the tree layout and the shape for links.
        const tree = d3.tree().nodeSize([dx, dy]);
        const diagonal = d3
          .linkHorizontal()
          .x((d) => d.y)
          .y((d) => d.x);

        // Create SVG
        const svg = d3
          .create("svg")
          .attr("width", width)
          .attr("height", dx)
          .attr("viewBox", [-marginLeft, -marginTop, width, dx])
          .attr(
            "style",
            "max-width: 100%; height: auto; font: 10px sans-serif; user-select: none; border: 2px solid black;"
          );
        svg.style("background-color", "#d8ecf3");

        const gLink = svg
          .append("g")
          .attr("fill", "none")
          .attr("stroke", "#212529")
          .attr("stroke-width", 1);

        const gNode = svg
          .append("g")
          .attr("cursor", "pointer")
          .attr("pointer-events", "all");

        function update(event, source) {
          const duration = 250;
          const nodes = root.descendants().reverse();
          const links = root.links();

          // Compute the new tree layout.
          tree(root);

          let left = root;
          let right = root;
          root.eachBefore((node) => {
            if (node.x < left.x) left = node;
            if (node.x > right.x) right = node;
          });

          let height = right.x - left.x + marginTop + marginBottom;

          const transition = svg
            .transition()
            .duration(duration)
            .attr("height", height)
            .attr("viewBox", [-marginLeft, left.x - marginTop, width, height])
            .tween(
              "resize",
              window.ResizeObserver ? null : () => () => svg.dispatch("toggle")
            );

          // Update nodes
          const node = gNode.selectAll("g").data(nodes, (d) => d.id);

          var div = d3
            .select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0);

          function getOffset(el) {
            const rect = el.getBoundingClientRect();
            return {
              left: rect.left + window.scrollX,
              top: rect.top + window.scrollY,
            };
          }

          // Enter any new nodes at the parent's previous position.
          const nodeEnter = node
            .enter()
            .append("g")
            .attr("transform", (d) => `translate(${source.y0},${source.x0})`)
            .attr("fill-opacity", 0)
            .attr("stroke-opacity", 0)
            .on("click", (event, d) => {
              // Never close root
              if (d.parent) {
                if (d._children) {
                  const parent = d.parent;
                  // Close all other nodes of parent except for self
                  R.tail(parent.descendants()).forEach((child) =>
                    child.id !== d.id ? (child.children = null) : null
                  );
                  d.children = d.children ? null : d._children;
                  update(event, d);
                } else if (d.data.story) {
                  let storyModal = document.getElementById("storyModal");

                  if (!storyModal) {
                    const modalContent = `<div class="modal fade" id="storyModal" tabindex="-1" aria-labelledby="storyModalLabel" aria-hidden="true">
                          <div class="modal-dialog modal-dialog-centered">
                              <div class="modal-content">
                                  <div class="modal-header">
                                      <h5 class="modal-title">${
                                        d.data.name
                                      } - ${formatter.format(
                      d.data.value
                    )} records affected</h5>
                                      <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                                  </div>
                                  <div class="modal-body">
                                      ${d.data.story}
                                  </div>
                              </div>
                          </div>
                      </div>`;

                    document.body.insertAdjacentHTML("beforeend", modalContent);

                    storyModal = new bootstrap.Modal(
                      document.getElementById("storyModal")
                    );
                    storyModal.show();
                  } else {
                    const modalTitle = storyModal.querySelector(".modal-title");
                    const modalBody = storyModal.querySelector(".modal-body");

                    modalTitle.innerText = `${d.data.name} - ${formatter.format(
                      d.data.value
                    )} records affected`;
                    modalBody.innerText = d.data.story;

                    const modalInstance =
                      bootstrap.Modal.getInstance(storyModal);
                    modalInstance.show();
                  }
                }
              }
            })
            .on("mouseover", function (event, d) {
              if (!d._children) {
                div.transition().duration(500).style("opacity", 1);
                div
                  .html("<h6>Click to read story</h6>")
                  .style("left", getOffset(this).left + 40 + "px")
                  .style("top", getOffset(this).top + 40 + "px")
                  .style("background-color", "white");
              }
            })
            .on("mouseout", (d) => {
              div.transition().duration(500).style("opacity", 0);
            });

          nodeEnter
            .append("circle")
            .attr("r", (d) =>
              normalizeScale(d.data.value, dataMin, dataMax, 100, 2.5)
            )
            .attr(
              "fill",
              (d) =>
                sectorColorPallette[d.data.name] ||
                sectorColorPallette[d?.parent?.data?.name] ||
                "#555"
            )
            .style("stroke", "black")
            .style("stroke-width", "1px");

          nodeEnter
            .append("text")
            .attr("dy", "0.31em")
            .attr("x", (d) => (d.depth == 0 ? 31 : d._children ? -6 : 6))
            .attr("text-anchor", (d) => (d._children ? "end" : "start"))
            .text((d) =>
              d._children
                ? d.data.name
                : d.data.name.concat(` | ${formatter.format(d.data.value)}`)
            )
            .attr("stroke-linejoin", "round")
            .attr("stroke-width", 3)
            .attr("stroke", "white")
            .attr("paint-order", "stroke");

          // Transition nodes to their new position.
          const nodeUpdate = node
            .merge(nodeEnter)
            .transition(transition)
            .attr("transform", (d) => `translate(${d.y},${d.x})`)
            .attr("fill-opacity", 1)
            .attr("stroke-opacity", 1);

          // Transition exiting nodes to the parent's new position.
          const nodeExit = node
            .exit()
            .transition(transition)
            .remove()
            .attr("transform", (d) => `translate(${source.y},${source.x})`)
            .attr("fill-opacity", 0)
            .attr("stroke-opacity", 0);

          // Update links
          const link = gLink.selectAll("path").data(links, (d) => d.target.id);

          // Enter any new links at the parent's previous position.
          const linkEnter = link
            .enter()
            .append("path")
            .attr("d", (d) => {
              const o = { x: source.x0, y: source.y0 };
              return diagonal({ source: o, target: o });
            });

          // Transition links to their new position.
          link.merge(linkEnter).transition(transition).attr("d", diagonal);

          // Transition exiting nodes to the parent's new position.
          link
            .exit()
            .transition(transition)
            .remove()
            .attr("d", (d) => {
              const o = { x: source.x, y: source.y };
              return diagonal({ source: o, target: o });
            });

          // Stash the old positions for transition.
          root.eachBefore((d) => {
            d.x0 = d.x;
            d.y0 = d.y;
          });
        }

        // Open First Node
        root.x0 = dy / 2;
        root.y0 = 0;
        root.descendants().forEach((d, i) => {
          d.id = i;
          d._children = d.children;
          if (d.depth) d.children = null;
        });

        update(null, root);

        container.append(svg.node());
      };
      /////////////////////////////////////////////////////////////////////////////////////////
      //                                 </ Elision>                                         //
      /////////////////////////////////////////////////////////////////////////////////////////
      /////////////////////////////////////////////////////////////////////////////////////////
      //                                  Circle Packing                                     //
      /////////////////////////////////////////////////////////////////////////////////////////
      const updateCirclePack = (data) => {
        // Specify the chart’s dimensions.
        const width = 928;
        const height = width;

        // Create the color scale.
        const color = d3
          .scaleLinear()
          .domain([0, 5])
          .range(["hsl(152,80%,80%)", "hsl(228,30%,40%)"])
          .interpolate(d3.interpolateHcl);

        // Compute the layout.
        const pack = (data) =>
          d3.pack().size([width, height]).padding(3)(
            d3
              .hierarchy(data)
              .sum((d) => d.value)
              .sort((a, b) => b.value - a.value)
          );
        const root = pack(data);

        // Create the SVG container.
        const svg = d3
          .create("svg")
          .attr("viewBox", `-${width / 2} -${height / 2} ${width} ${height}`)
          .attr("width", width)
          .attr("height", height)
          .attr(
            "style",
            `max-width: 100%; height: auto; display: block; margin: 0 -14px; background: ${color(
              0
            )}; cursor: pointer;`
          );

        // Append the nodes.
        let node = svg
          .append("g")
          .selectAll("circle")
          .data(root.descendants().slice(1))
          .join("circle")
          .attr("fill", (d) => (d.children ? color(d.depth) : "white"))
          .attr("pointer-events", (d) => (!d.children ? "none" : null))
          .on("mouseover", function () {
            d3.select(this).attr("stroke", "#000");
          })
          .on("mouseout", function () {
            d3.select(this).attr("stroke", null);
          })
          .on(
            "click",
            (event, d) =>
              focus !== d && (zoom(event, d), event.stopPropagation())
          );

        // Append the text labels.
        const label = svg
          .append("g")
          .style("font", "10px sans-serif")
          .attr("pointer-events", "none")
          .attr("text-anchor", "middle")
          .selectAll("text")
          .data(root.descendants())
          .join("text")
          .style("fill-opacity", (d) => (d.parent === root ? 1 : 0))
          .style("display", (d) => (d.parent === root ? "inline" : "none"))
          .text((d) => d.data.name);

        // Create the zoom behavior and zoom immediately in to the initial focus node.
        svg.on("click", (event) => zoom(event, root));
        let focus = root;
        let view;
        zoomTo([focus.x, focus.y, focus.r * 2]);

        function zoomTo(v) {
          const k = width / v[2];

          view = v;

          label.attr(
            "transform",
            (d) => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`
          );
          node.attr(
            "transform",
            (d) => `translate(${(d.x - v[0]) * k},${(d.y - v[1]) * k})`
          );
          node.attr("r", (d) => d.r * k);
        }

        function zoom(event, d) {
          const focus0 = focus;

          focus = d;

          const transition = svg
            .transition()
            .duration(event.altKey ? 7500 : 750)
            .tween("zoom", (d) => {
              const i = d3.interpolateZoom(view, [
                focus.x,
                focus.y,
                focus.r * 2,
              ]);
              return (t) => zoomTo(i(t));
            });

          label
            .filter(function (d) {
              return d.parent === focus || this.style.display === "inline";
            })
            .transition(transition)
            .style("fill-opacity", (d) => (d.parent === focus ? 1 : 0))
            .on("start", function (d) {
              if (d.parent === focus) this.style.display = "inline";
            })
            .on("end", function (d) {
              if (d.parent !== focus) this.style.display = "none";
            });
        }

        circleContainer.append(svg.node());
      };
      updateElision(treeMapData);
      updateCirclePack(treeMapData);
    </script>
  </body>
</html>
